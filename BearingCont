
import math as m
import numpy as np

#test values
n = 4
x = 1
z = 1
cg_z = 2
cg_x = 1
F_z = 5
F_x = 10
coo = [[0,0],[1,1],[2,3]]

def SumR_Squared (coo,cg_x,cg_z): # is the sum of the square distances of each fastener to the c.g. of the fasteners
    R = []
    for i in coo:
        r_squared = (float(i[0])-cg_x)**2+(float(i[1])-cg_z)**2
        R.append(r_squared)
        S = sum(R)
    return S


def InplaneForce (n,x,z,cg_x,cg_z,F_x,F_z):  #Required Variables: number of fast., coo single fast., S: see above, coo cg(4.5), force components (4.1)
    #check whether resultant of F_x and F_z acts through the cg of the fasteners
    F_inplane_x = F_x / n
    F_inplane_z = F_z / n

    if cg_x == 0 and cg_z == 0:
        F_inplane_M = 0

    else: # the following vectors are treated as if they were in a regular x-y plane , the variables are however different: x -> z, y -> x (see drawing reference system)
        d = np.array([cg_z,cg_x]) # vector representing moment arm                              #     ^ x
        F = np.array([F_z,F_x]) # vector representing resultant force vector                    #     |
                                                                                                #     |
                                                                                                #     ._ _ _ _> z
        M = abs(np.cross(d,F))
        #print(d)
        #print(F)
        print(M)
        r = m.sqrt((z-cg_z)**2+(x-cg_x)**2)
        print(r)
        S = SumR_Squared(coo,cg_x,cg_z)
        print(S)
        F_inplane_M = (M*r)/S    # looking at Eq 4.4 in the manual a more general version is represented, however since all cross-sectional areas will bes the same, this eqaution can be simplified by putting the area outside the summation, and thus cancelling out

        #print(F_inplane_x,F_inplane_z ,F_inplane_M)
        forces = np.array([F_inplane_x,F_inplane_z ,F_inplane_M ])
        return forces

print(InplaneForce(n,x,z,cg_x,cg_z,F_x,F_z))




